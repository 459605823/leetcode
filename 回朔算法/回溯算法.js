// Backtracking algorithm 回溯算法
// 回溯算法实际上一个类似枚举的深度优先搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，
// 当发现已不满足求解条件时，就“回溯”返回（也就是递归返回），尝试别的路径。

// 总的来说，如果要解决一个回溯法的问题，通常要确定三个元素：
// 1、选择。
// 对于每个特定的解，肯定是由一步步构建而来的，而每一步怎么构建，肯定都是有限个选择，要怎么选择，这个要知道；
// 同时，在编程时候要定下，优先或合法的每一步选择的顺序，一般是通过多个if或者for循环来排列。
// 2、条件。
// 对于每个特定的解的某一步，他必然要符合某个解要求符合的条件，如果不符合条件，就要回溯，其实回溯也就是递归调用的返回。
// 3、结束。
// 当到达一个特定结束条件时候，就认为这个一步步构建的解是符合要求的解了，把解存下来或者打印出来。
// 注意，当到达第三步后，有时候还需要构建一个数据结构，把符合要求的解存起来，
// 便于当得到所有解后，把解空间输出来。这个数据结构必须是全局的，作为参数之一传递给递归函数。


// 对于回溯法来说，每次递归调用，很重要的一点是把每次递归的不同信息传递给递归调用的函数。而这里最重要的要传递给递归调用函数的信息，
// 就是把上一步做过的某些事情的这个选择排除，避免重复和无限递归。另外还有一个信息必须传递给递归函数，就是进行了每一步选择后，
// 暂时还没构成完整的解，这个时候前面所有选择的汇总也要传递进去。而且一般情况下，都是能从传递给递归函数的参数处，得到结束条件的。

// 1. 必须有一个临时变量，来存储当前选择的不完整解，并将当前的不完整解传递给递归函数，也就是把每次递归的不同情况传递给递归调用的函数
// 2. 有一个全局变量存储完整的每个解
// 3. 一定要在参数设计中可以得到结束条件

lastDigits.forEach(function(digit){
  var arr = []
  map[digit].forEach(function(letter){
  // arr为临时变量，存储当前递归的选择的解
    arr = arr.concat(ans.map(function(item){
      return item + letter
    }))
  })
 // ans为全局变量，存储完整的每个解
  ans = arr
})

// 参数设计:arr为全局存储完整解的变量，curStr为当前选择，left和right存储当前选择的有关信息，max为结束条件
var backtrack = function(arr, curStr, left, right, max) {
  // 结束条件: 当当前选择的长度达到条件时，就返回
  if(curStr.length == 2 * max){
    arr.push(curStr)
    return
  }

  if(left < max){
    backtrack(arr, curStr + "(", left + 1, right, max)
  }

  if(right < left){
    backtrack(arr, curStr + ")", left, right + 1, max)
  }
}
